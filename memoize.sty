\ProvidesPackage{memoize}
\RequirePackage{pgfkeys}
\RequirePackage{etoolbox}
\RequirePackage{graphics}

\ifdef\pdftexversion{\input memoize-pdftex.def}{%
  \ifdef\XeTeXversion{\input memoize-xetex.def}{%
    \PackageError{memoize}{Support for this TeX engine is not implemented.}{}%
  }}

% UI
\def\memoizeset#1{\pgfqkeys{/memoize}{#1}}
\def\mmz@valueof#1{\pgfkeysvalueof{/memoize/#1}}
\memoizeset{%
  % When the TeX job starts, \jobname contains the basename of the PDF that
  % will
  % be created.  If memoization is enabled, we store the name of this PDF
  % (\jobname.pdf) into \memoize@output@pdf, and set \jobname using key "real
  % job". This way, we will be using and writing the auxiliary files of the
  % real
  % job. In particular, we will create <real job>.mmz that contains info on
  % what was just externalized.
  real job/.code={%
    \edef\memoize@output@pdf{\jobname.pdf}%
    \edef\jobname{#1}%
  },
  % Default: We output to the real job output file.
  real job=\jobname,
  % 
  % The key "fragments" tells the package where to store the separate
  % externalized pictures.  For example, say "fragments={\jobname.mmz/#1}", to
  % store them in the "\jobname.mmz" folder --- where \jobname is the name of the
  % real job.
  %
  % todo: context dependency
  fragments/.code={\def\mmz@fragment@filename##1{#1}},
  % Default: We store the externalized files in the same folder, because we
  % don't know if we can write elsewhere. The name is set so that it is easy to
  % clean up: "rm <jobname>.mmz*" will remove all memoization info.
  fragments={\jobname.mmz.#1},
  % todo: better interface for switching the engine and format; can the engine
  % be automatic?
  latex system call/.initial={\mmz@latex@binary\space
    -halt-on-error
    -interaction=batchmode
    -jobname "\detokenize\expandafter{\mmz@syscall@jobname}"
    "\detokenize\expandafter{\mmz@syscall@commands}"},
  % todo: option "active"
}

% Registers and such
\newwrite\mmz@main@out
\newwrite\mmz@fragment@out
\newbox\mmz@box
\newcount\mmz@realpage

% A .mmz file consists of a series of calls to \memoized containing, for each
% md5 id, the memoized information and the link to the correct page of the PDF.
\def\memoized#1#2#3#4{%
  % todo: If there's several \memoized calls with the same md5 id, find the
  % right one --- dependencies!
  \def\mmz@id{#1}%
  \def\mmz@filename{#2}%
  \def\mmz@page{#3}%
  \def\mmz@dp{#4}%
}

% manual memoization: #1 is the code to be memoized
\def\memoize#1{%
  % Compute the MD5 sum of the code.
  \edef\mmz@ID{\expandafter\mmz@mdfivesum\expandafter{\detokenize{#1}}}%
  \mmz@leavevmode
  % Use or create?
  \mmz@ifmemoized{\mmz@use@memoized}{\mmz@memoize{#1}}%
  % In both cases, we are left with \mmz@box
  \box\mmz@box
}

% \mmz@ifmemoized{true code}{false code}
% Is there memoized data for \mmz@ID? If yes, leave it in various macros (see
% \memoized) and execute {true code}. If no, \mmz@filename will be undefined
% and we run {false code}.
\def\mmz@ifmemoized{%
  % If inputing <id>.mmz sets the filename, we found it!
  \undef\mmz@filename
  \@input{\mmz@fragment@filename\mmz@ID}%
  \ifdef\mmz@filename{%
    % Well ... if that file exists.
    \IfFileExists{\mmz@filename}{%
      % Yes! Unless ...
      \edef\mmz@marshal{\noexpand\ifstrequal{\mmz@id}{\mmz@ID}}%
      \mmz@marshal{}{%
        \PackageWarning{memoize}{Something is wrong here. I found
          data for "\mmz@id" in file "\mmz@fragment@filename\mmz@ID"}%
      }%
      % Yes:
      \@firstoftwo
      % No:
    }{\@secondoftwo}}{\@secondoftwo}%
}

% We use the "graphics" package, so we don't have to deal with various TeX
% engines.
\def\mmz@use@memoized{%
  \PackageInfo{memoize}{Using \mmz@id\space on input line \the\inputlineno}%
  \setbox\mmz@box=\hbox{\lower\mmz@dp\hbox{\includegraphics{\mmz@filename}}}%
}

% Memoize and leave the box in \mmz@box.
\def\mmz@memoize#1{%
  % If there was no memoized data:
  \PackageInfo{memoize}{Memoizing \mmz@ID\space on input line \the\inputlineno}%
  % Typeset the code.
  \setbox\mmz@box=\hbox{#1}%
  {%
    % Debug PDF: \pdfcompresslevel=0 \pdfobjcompresslevel=0
    \mmz@prepare@fragment@page
    % Use the original \shipout here, otherwise we can get in trouble with other
    % packages like pdfpages.  Let's just hope that (i) some other package
    % doesn't count shipouts as well (then, they are in trouble), or (ii) doesn't
    % use the primitive \shioput (then, we are in trouble).
    \global\advance\mmz@realpage1
    \mmz@primitive\shipout\copy\mmz@box
  }%
  % Store memoized data.
  % todo: immediately store in \jobname.\mmz@ID.tex
  \immediate\openout\mmz@fragment@out=\mmz@fragment@filename\mmz@ID
  \immediate\write\mmz@fragment@out{%
    \noexpand\memoized{\mmz@ID}{\memoize@output@pdf}{\the\mmz@realpage}{\the\dp\mmz@box}\@percentchar
    % todo: an option to write out the memoized code, for debugging or manual
    % inspection.
  }%
  \immediate\closeout\mmz@fragment@out
  \immediate\write\mmz@main@out{\noexpand\justmemoized{\mmz@ID}\@percentchar}%
}

% Used to process .mmz to split the resulting bit PDF into individual
% externalized pictures.

\def\justmemoizedto#1{\def\mmz@justmemoizedto{#1}}

\def\justmemoized#1{%
  \def\mmz@ID{#1}%
  \undef\mmz@filename
  \@input{\mmz@fragment@filename\mmz@ID}%
  \ifdef\mmz@filename{%
    % Split the relevant page off to the fragment pdf.
    \edef\mmz@syscall@jobname{\mmz@fragment@filename{#1}}%
    % todo: test: \mmz@filename matches \mmz@justmemoizedto?
    \edef\mmz@marshal{%
      \noexpand\justmemoized@prepare@syscall@commands{\mmz@filename}{\mmz@page}%
    }\mmz@marshal
    \immediate\write18{\mmz@valueof{latex system call}}%
    % Relink the fragment .mmz from the main pdf to the fragment pdf
    % (\mmz@fragment@filename#1.pdf)
    \immediate\openout\mmz@fragment@out=\mmz@syscall@jobname
    \immediate\write\mmz@fragment@out{%
      \noexpand\memoized{#1}{\mmz@syscall@jobname.pdf}{1}{\mmz@dp}\@percentchar}%
    \immediate\closeout\mmz@fragment@out
  }{\justmemoized@error}%
}
\def\justmemoized@prepare@syscall@commands#1#2{%
  % By using pdfpages, we don't care about the engine we use.  And we're bound
  % to LaTeX anyway ...
  \def\mmz@syscall@commands{%
    \documentclass{minimal}
    \usepackage{pdfpages}
    \begin{document}
    \includepdf[pages=#2,fitpaper]{#1}
    \end{document}
  }%
}%

\def\justmemoized@error{%
  \PackageWarning{memoize}{Cannot find \mmz@fragment@filename\mmz@ID,
    which I supposedly generated in the previous run, or
    \mmz@fragment@filename\mmz@ID.pdf, which I should have created just now.}%
}

% Split.
\@input{\jobname.mmz}%

% Hijack TeX's \shipout. Do it at the beginning of the document, in case some
% other package mucked with it as well.
\def\memoizePatchShipout{%
  \let\mmz@orig@shipout\shipout
  \def\shipout{%
    \global\advance\mmz@realpage1
    \mmz@orig@shipout
  }%
}
% todo: For funky situation: an option to not do it, and instruct the user to
% use \memoizePatchShipout in an appropriate place instead.
\AtBeginDocument{\memoizePatchShipout}
% We only need this to count pages. Can it be done otherwise?
% Actually, this could be used to supress normal output as well.


% Open and close .mmz file.
\AtBeginDocument{%
  \immediate\openout\mmz@main@out=\jobname.mmz
  \immediate\write\mmz@main@out{%
    \noexpand\justmemoizedto{\memoize@output@pdf}\@percentchar}%
}
\AtEndDocument{\immediate\closeout\mmz@main@out}


%%%% Automatically memoizing commands and environments

% A lighter approach (without xparse) for easy stuff:
% handlers
% \memoizeset{%
%   def/.code={\AtBeginDocument{%
%       \cslet{\mmz@orig@string#1}#1%
%       \def#1##1{\memoize{\mmz@orig#1{##1}}}%
%     }},
%   def 1/.style={def={#1}},
%   prefixed def/.code 2 args={\AtBeginDocument{%
%       \cslet{\mmz@orig@string#2}#2%
%       #1\def#1##2{\memoize{\mmz@orig#2{##1}}}%
%     }},
%   newcommand/.code={\AtBeginDocument{%
%       \cslet{\mmz@orig@string#1}#1%
%       \reqnewcommand#1{\memoize{\mmz@orig#1{##1}}}%
%     }},
%   newcommand[1]/.style={newcommand={#1}},
%   newcommand[][2]/.code 2 args={\AtBeginDocument{%
%       \cslet{\mmz@orig@string#2}#2%
%       \renewcommand#2[2][#1]{\memoize{\mmz@orig#2[##1]{##2}}}%
%     }},
% }

\def\mmz@orig#1{mmz@orig\string#1}
\def\mmz@repl#1{mmz@repl\string#1}

\def\memoizeRenewDocumentCommand#1#2#3{%
  \AtBeginDocument{\memoizeRenewDocumentCommandNow{#1}{#2}{#3}}}
\def\memoizeRenewDocumentCommandNow#1#2#3{%
  \cslet{\mmz@orig#1}#1%
  \expandafter\NewDocumentCommand\csname\mmz@repl#1\endcsname{#2}{#3}%
  \letcs#1{\mmz@repl#1}%
}

% Note: this switches off internal externalization.
\def\mmz#1#2{%
  \letcs#1{\mmz@orig#1}%
  \memoize{#1#2}%
  \letcs#1{\mmz@repl#1}%
}

% Predefined handlers
\usepackage{xparse}
\memoizeRenewDocumentCommand\tikz{O{} m}{\mmz\tikz{[#1]{#2}}}
\memoizeRenewDocumentCommand\Forest{s D(){} m}{%
  \IfBooleanT{#1}{\mmz\Forest{*(#2){#3}}}{\mmz\Forest{(#2){#3}}}}

% ideas:
% - could \pdfdraftmode be useful?
% - ditto for \pdflastximagepages

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "test1"
%%% End:
